% # -*- coding: utf-8 -*-
\input{ctex4xetex.cfg}
\documentclass{ctexbook}
\usepackage{asymptote}
\usepackage[pdftex]{geometry}
\geometry{left=2.5cm,right=2.5cm,top=3.5cm,bottom=2.5cm}

\input{fzfonts.tex}

\usepackage{mflogo}

% 数学相关设置
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bm}
\usepackage{upgreek}
\let\leq\leqslant
\let\geq\geqslant
\newcommand\set[1]{\left\{ #1 \right\}}
\newcommand\Set[2]{\left\{\, #1 \, \middle\vert \, #2 \,\right\}}
\newcommand\dif{\mathrm{d}}
\newcommand\diff{\,\dif}
\newcommand\mi{\mathrm{i}}

\usepackage{longtable}

\input{asysyntax.tex}

\usepackage{graphicx}

\usepackage{hyperref}


\lstdefinestyle{funclist}{style=lesscolor,
  xleftmargin={0pt},
  xrightmargin={0pt},
  backgroundcolor=}
\newenvironment{funclist}{\trivlist
  \parindent=0pt
\item[]
  \def\item{\medskip\par\leftskip=0pt}
  \def\go{\par\leftskip=4em}}
{\endtrivlist}

\makeatletter
\newenvironment{typelist}{\itemize
  \let\old@item\@item
  \def\@item[##1]{\expandafter\old@item[\ttfamily\color{type!50!black}##1]}}
{\enditemize}
\makeatother


\CTEXsetup[format={\Large\bfseries}]{section}

% 页眉（无 fancyhdr）字体修正
\makeatletter
\let\old@evenhead\@evenhead
\let\old@oddhead\@oddhead
\def\@evenhead{\normalfont\old@evenhead}
\def\@oddhead{\normalfont\old@oddhead}
\makeatother

\newcommand*\prgname[1]{\textsf{#1}}
\newcommand\transnote[1]{\footnote{#1——译者注}}
\newcommand\asyversion{1.65}

\usepackage{hyperref}
\hypersetup{bookmarksopen=false,
  bookmarksnumbered=true,
  pdftitle={绘图语言 Asymptote 初步},
  pdfauthor={cvgmt@bbs.ctex.org},
  pdfsubject={asy4cn},
  pdfcreator={XeLaTeX + xeCJK},
  pdfkeywords={Asymptote,MetaPost,latex, 编程语言,绘图},
  pdfstartview={FitH}
}

\begin{document}

% \title{Asymptote 绘图语言初步}
% \author{cvgmt 编著}
% \date{\today}
% \maketitle

% 说明：nil 

\setcounter{chapter}{1}
\chapter{2D 绘图}

\section{基本的绘图命令}
Asymptote 的绘图基于 |draw|, |fill|, |clip| 以
及 |label| 四个原始的命令. 前三个根源于 PostScript 的绘图命令, 最后一
个用于在图形上添加字母和图形, 此处即调用了 \LaTeX 的功能.

举一个综合的例子.
\begin{center}\includegraphics[height=4cm]{Example.pdf}\end{center}%
\lstinputlisting{Example.asy}
\begin{itemize}
\item 每一个完整的命令语句以 |;| 结尾.
\item 其中 |size(200,200);| 可以理解为我们输出图形大小是 $200\times 200$ 
  的图形. 可以省略为 |size(200);|.
\item {unitcircle} 是 Asymptote 预定义的路径, 表示半径为 $1$ 的
  圆. 现在调用 |draw| 命令画出.
\item 同理, 其后的一句是在封闭的路径中填上黄色.
\item 最后一句是在坐标为 $(0,0)$ 处标上字母 $O$, 其中引号内的 |$O$|
  被会输送到一个 \TeX 文件中生成相应的字母, 然后再标在 $(0,0)$ 位置. 
\end{itemize}

我们先试试一些简单的绘图例子, 等对 asy 语言有一定了解以后才开始学习它的
语法.

\section{画线段和点}
\begin{center}\includegraphics[scale=0.5]{Segment-Points.pdf}\end{center}%
\lstinputlisting{Segment-Points.asy}
\begin{itemize}
\item |pair| 用来声明一种称为二元组的数据类型, 表示平面坐标. 现在对 $A$,
  $B$, $C$ 同时声明, 用了逗号连接(称为逗号运算符).
\item |--| 表示用直线连接两点.
\item |dot| 用于画出一个实心点, 其后加上 |UnFill| 就得到
  空心的点. 这个 |UnFill| 真正的把点挖空, 而不是用白色填充, 这是
  Asymptote 提供的重要功能之一.
\end{itemize}

\section{画虚线}
\begin{center}\includegraphics[scale=0.5]{Dashed-Line.pdf}\end{center}%
\lstinputlisting{Dashed-Line.asy}
\begin{itemize}
\item  其中 |solid| 可以省略, 表示画实线; 
\item |dashed| 画虚线.
\item |dashdotted| 画点划线.
\item |dotted| 画实心点线.  
\end{itemize}
更多线的类型将在后面阐述.

\section{画箭头}
\begin{center}\includegraphics[height=6cm]{Arrows.pdf}\end{center}%
\lstinputlisting{Arrows.asy}

\begin{itemize}
\item |Arrow| 与 |EndArrow| 效果一样, 都是在路径的末端添
  加箭头.
\item |BeginArrow| 在路径的开头加箭头.
\item |Arrows| 在路径的头尾都加上箭头.
\item |MidArrow| 则是在路径的中间添加箭头.
\end{itemize}
|Arrow| 其实是一个函数, 我们可以带上一些参数控制它的大小, 形状以及安放
的位置, 这些在后面再详细论述.

Asymptote 预先定义了一些表示方向的二元组,比如  |E=(1,0)|,
|S=(0,-1)|, |W=(-1,0)|, |N=(0,1)| 以及它们的复合
|NE| 等等. 因为二元组同时也表示平面坐标系中的点, 因此, 这些方向
同时也表示点. 举一个综合一点的例子, 

\begin{center}\includegraphics[scale=0.8]{Compass-1.pdf}\end{center}%
\lstinputlisting{Compass-1.asy}

其中 |label| 是 Asymptote 里面的一个函数, 用于标字母或图形, 可
以事先指定标的位置(|position|) 以及相对与那个位置的放法(|align|), 因此, 该函
数的调用格式之一是:
\begin{verbatim}
label(Label,position,align);
\end{verbatim}
如最后一行我们把 $NE$ 这个 |Label| 标在 |position=NE| 这个点的东北
(|align=NE|).

从刚才那个例子, 我们可以初步了解到 Asymptote 中的函数都可以加上一些数
据, 我们把这些数据称为该函数的\emph{参数}. 另外, 函数也可以复合. 比如
我们可以让 |draw| 和 |Label| 函数复合, 以便同时画方向以及在其实标字母.

\begin{center}\includegraphics[scale=0.8]{Compass-2.pdf}\end{center}%
\lstinputlisting{Compass-2.asy}

当然, 更为重要的时, 我们可以同时控制 |Label| 与 |draw| 的关系, 从而达
到把 |Label| 标在我们希望的位置.

\section{画线段按比例的分点}
对两个点 $A$ 和 $B$ 构成的线段(我们后面称为 {path} 的数据类型),
我们可以用 |midpoint| 函数来求它们的中点.
调用格式是:|midpoint(path)|

\begin{center}\includegraphics[scale=0.6]{Midpoint.pdf}\end{center}%
\lstinputlisting{Midpoint.asy}

其中 |--cycle| 表示我们用 |--| 这种连接方式使得所画的路
径是封闭而且是周期循环的.特别要注意的是: |A--B--C--cycle| 与
|A--B--C--A| 是不一样的. 后者并不形成一个封闭路径, 它只是一条首尾
巧好是同一个点的路径.因此, 也只有前者才可以在有它围成的封闭区域填上
颜色.那个 |filldraw| 就是把路径填上颜色的同时把该路径围成的封闭
区域也填上颜色.这两个颜色可以不一样.
\begin{center}\includegraphics[scale=0.5]{FillDraw.pdf}\end{center}%
\lstinputlisting{FillDraw.asy}

一般的, 我们用 |T interp(T a, T b, real t)| 表示
|a+t*(b-a)|, 即从 |a| 往 |b| 方向走到占整段比
例为 |t| 的地方, 于是当比例 |t=1/2| 是就是中点. 另外,
|T| 可以代任意有加减乘运算的一些诸如 |real|,
|pair| 等的数据类型. 
\begin{center}\includegraphics[scale=0.6]{Interp.pdf}\end{center}%
\lstinputlisting{Interp.asy}

\section{画过若干个点的曲线}
用 |..| 表示这种
与直线不一样的连接两个点方式. 这种画曲线原理将在后面讲到. 

现在我们可以利用四个点 $E$, $N$, $W$, $S$ 来画出一个与圆非常接近的图形.
\begin{center}\includegraphics[scale=0.5]{Circle.pdf}\end{center}%
\lstinputlisting{Circle.asy}

下面我们利用曲线功能画一些有趣一点的图形. 
\begin{center}\includegraphics[scale=0.5]{Heart.pdf}\end{center}%
\lstinputlisting{Heart.asy}

\section{变量与函数}
我们在前面其实已经接触到\emph{变量}和\emph{函数}这两个概念, 在这里阐述
一下. Asymptote 中的\emph{变量}就是在使用之前要预先定义好的数据类型. 比如前
面的表示方向的 |E|, |N|, |W|, |S| 以及各种
颜色 |red|, |green| 等等. 用户也可以自定义一些变量,但一
定要事先声明它的数据类型. 这种语法与 C++/Java 是类似的(但本书不假定读者
学过任何语言).至于 \emph{函数}, 在 Asymptote 中也把它看成变量, 我们说它是一种一阶变
量, 于是普通的 \emph{变量} 就可以看成零阶变量, 两个函数复合就是更高阶的
变量. 这是 Asymptote 语言最为独特的一点, 也使得我们在函数中调用或定义函
数非常方便. Asymptote 预先定义了很多画基本图形的函数, 可以直接调用, 不过我们心里面
要清楚函数需要的参数是什么.这些常用的函数包括(后面会看到, 如果调用
\begin{itemize}
\item {box(矩形的左下角, 矩形的右上角);}
\item {ellipse(椭圆的中心,水平方向的轴长,竖直方向的轴长);}
\item {drawline(直线的第一个点, 直线上的第二个点);}
\end{itemize}

\begin{center}\includegraphics[scale=0.5]{Box-Circle-Ellipse.pdf}\end{center}%
\lstinputlisting{Box-Circle-Ellipse.asy}

\section{画正多边形}
\begin{center}\includegraphics[scale=0.5]{Polygon.pdf}\end{center}%
\lstinputlisting{Polygon.asy}

\section{画圆弧}
圆弧是圆的一部分, 用 |arc| 函数.
\begin{lstlisting}
  path arc(pair c, real r, real angle1, real angle2);
\end{lstlisting}

\begin{center}\includegraphics[scale=0.5]{Arc.pdf}\end{center}%
\lstinputlisting{Arc.asy}

其中 |defaultpen(linewidth(4));| 把默认的画笔的设为 |4bp| 粗细.

有时候我们希望画一个角之间的圆弧, 比如通常的平面几何的图形中给角做一个
标记, 默认的作图没有这个功能, 这时就要调用 Asymptote 里面的 geometry 宏包. 
\begin{center}\includegraphics[scale=0.5]{Angle-Mark.pdf}\end{center}%
\lstinputlisting{Angle-Mark.asy}

\section{画直角记号}
直角符号用 |perpendicular| 函数,同样要调用 |geometry| 宏
包. 基本的用法是
\begin{verbatim}
perpendicular(pair z,pair align,pair dir);
perpendicular(pair z,pair align,path g);
\end{verbatim}
该直角是相对 |z--z+dir| 的, |align| 表明它的安置的方位,
给出路径 |g| 的话, Asymptote 会把它转成该路径 |g| 的切线
方向(关于路径的切线方向我们以后阐述).
\begin{center}\includegraphics[scale=0.5]{Perpendicular.pdf}\end{center}%
\lstinputlisting{Perpendicular.asy}

\section{自定义函数}
我们也可以自己定义新函数. 假定我们要画一条抛物线 $y=x^{2}$, 我们要预先定义一个函数. 格式如下
\begin{lstlisting}
  real f(real x){return y=x^2;};
\end{lstlisting}
其中 |real x| 声明函数自变量 |x| 是实数型, |f| 前面的
|real| 声明函数 |f| 也是一个实数型. 

\section{画参数曲线}
利用若干个点画曲线能力有限, 我们可以利用数学中的参数曲线来生成更丰富多
彩而且有意义的曲线.
\begin{center}\includegraphics[scale=0.5]{Parameter-Curve-1.pdf}\end{center}%
\lstinputlisting{Parameter-Curve-1.asy}

函数 |graph| 是一个返回数据类型为路径 |path| (其实是称为 |guide| 的
数据类型, 与 |path| 稍微有些区别)的函数.它需要知道要画的函数
|real f(real x)|,  所画函数自变量的变换范围, 还有就是用折线画
还是用光滑曲线画.因此, 前面代码调用它的格式如下:
\begin{lstlisting}
  guide graph(real f(real), real a, real b,interpolate join=operator --);
\end{lstlisting}
\begin{center}\includegraphics[scale=0.8]{Parameter-Curve-2.pdf}\end{center}%
\lstinputlisting{Parameter-Curve-2.asy}

\begin{itemize}
\item 在 |Label()| 函数中加 |position=EndPoint|,那么就
  会标在所画曲线的末端.
\item  类似地,标 $y$ 轴时用 |align=N| 把 $y$ 安置(|align|)在 $y$ 轴默认的
  |position=EndPoint| 的北边.
\end{itemize}

\section{画阴影}
传统的图形, 特别是印成黑白颜色的图形, 通常是希望在封闭曲线里面填上阴影
而不是颜色. Asymptote 的宏包 {patterns} 提供了一些模式, 我们先
讲最常见的一种 hatch 画阴影. 
\begin{center}\includegraphics[scale=0.5]{Hatch.pdf}\end{center}%
\lstinputlisting{Hatch.asy}
\begin{itemize}
\item {hatch(NW)} 是一种西北走向的阴影斜线的图形. 用
  |add("name",hatch(NW));| 命名为 "name". 
\item 接下去用 |pattern("name")| 的方式把它做成一个类似与颜色的
  画笔.
\item |hatch()| 函数还有其他参数, 比如线的粗细, 线的间隔等.
\end{itemize}

\section{子图}
在 Asymptote 中我们可以独立的画一些图, 然后再分别添加到图上.这时,我们
可以定义一些称为 {picture} 的数据类型.
\begin{center}\includegraphics[scale=0.5]{Sub-Picture-1.pdf}\end{center}%
\lstinputlisting{Sub-Picture-1.asy}

这与直接画的效果似乎是一样的, 不过用这种独立画的方式的其中一个便利的地
方是可以随意控制图片的画出顺序.这时候用 {above=true} 和 {above=false}
控制的. 
\begin{center}\includegraphics[scale=0.5]{Sub-Picture-2.pdf}\end{center}%
\lstinputlisting{Sub-Picture-2.asy}

我们看到, 现在最后加上的图反而给前面画的图盖住了. 这种灵活的独立图形的
输出的是独立画图的好处之一.这个也用在下面的 |clip| 命令用法当中
以及以后的动画制作.

\section{裁剪命令 clip}
除了前面已经阐述的 |draw|,|fill|,|label| 三个基本命令以外, 还有一个
|clip| 命令, 可以借助于封闭曲线裁剪出该曲线围成的区域里面的部分.
\begin{lstlisting}
  clip(picture pic=currentpicture, path g, stroke=false, pen fillrule=currentpen);
\end{lstlisting}

\begin{center}\includegraphics[scale=0.5]{Clip-1.pdf}\end{center}%
\lstinputlisting{Clip-1.asy}

利用 |clip| 这个函数, 我们可以任意地裁剪出我们所想要的东西, 然后再用
|add| 函数添加. 
\begin{center}\includegraphics[scale=0.5]{Clip-2.pdf}\end{center}%
\lstinputlisting{Clip-2.asy}

我们定义了一个子图 |pic| 用来独立画一个虚线单位圆, 然后用路径
|p| 把它剪下来.最后在用 |add| 添加到图上.

下面的 Venn 图的例子运用上面技巧画出了两个集合交集部分的.
\begin{center}\includegraphics{Clip-3.pdf}\end{center}%
\lstinputlisting{Clip-3.asy}

\section{unfill 命令}
Asymptote 利用 |clip| 这个功能定义了一个非常好用的 |unfill| 命令, 可以
利用封闭曲线来挖洞. 前面我们已经见过 |UnFill|, 再举一个例子.

\section{奇偶法则填颜色}

我们前面已经看到 {fill} 命令可以在封闭循环的路径内填上各种颜色.
\begin{center}\includegraphics[scale=0.6]{EvenOdd.pdf}\end{center}%
\lstinputlisting{EvenOdd.asy}
\section{变换}
变换可以使得我们可以利用原来的图形来生成新的图形. Asymptote 可以进行一
般的仿射变换, 即可以进行旋转, 伸缩, 旋转, 反射等变换以及它们的复合. 

平移变换是
\begin{lstlisting}
  transform shift(real x,real y);
  transform shift(pair z);
\end{lstlisting}
分别为依照向量 |(x,y)| 和 |z| 平移.

\begin{center}\includegraphics[scale=0.6]{Shift.pdf}\end{center}%
\lstinputlisting{Shift.asy}

伸缩变换包括
\begin{lstlisting}
  transform xscale(real x); 
  transform yscale(real y); 
  transform scale(real s);  
  transform scale(real x, real y); 
\end{lstlisting}

\begin{lstlisting}
  transform slant(real s);
\end{lstlisting}

错切变换 |slant| 变换把点 |(x,y)| 变换为 |(x+s*y,y)|.
\begin{center}\includegraphics[scale=0.8]{Slant.pdf}\end{center}%
\lstinputlisting{Slant.asy}
从图中可以看到, 点 |(0.5,0.5)| 经过错切 |slant(2)| 变换后变成点 
|(1.5,0.5)|. 

\begin{lstlisting}
  transform rotate(real angle, pair z=(0,0));
\end{lstlisting}
旋转变换 |rotate| 是绕着点 |z| 旋转 |angle| 度数. 默认是绕着坐标原点旋
转.
\begin{center}\includegraphics[scale=0.8]{Rotation.pdf}\end{center}%
\lstinputlisting{Rotation.asy}

\begin{lstlisting}
  transform reflect(pair a, pair b);
\end{lstlisting}
反射变换是以 |a--b| 这条直线为对称轴反射.


\section{简单的编程}
Asymptote 的语法类似于 C, C++, 以及 Java. 不过本书不假定读者有任何的编
程语言背景, 反而是希望直接学习 asy 这种有趣的绘图语言.

我们在前面已经接触了它的一些语法, 这里归纳一下.首先, 每一个\emph{变量}都要声
明它的数据类型.比如

\begin{lstlisting}
  real x;
  pair z;
\end{lstlisting}
然后对应地赋予相应的值.
\begin{lstlisting}
  x=1.0;
  z=(3.0,4.0);
\end{lstlisting}

最后,就是一些程序设计语言都有的判断语句和循环语句.我们在这里说一下用
的最多的 |for| \emph{循环语句}.

假定我们要画半径分别为 $1$, $2$, $3$,...
的几个同心圆, 我们当然可以如下画出:
\begin{center}\includegraphics[scale=0.6]{Circle-3.pdf}\end{center}%
\lstinputlisting{Circle-3.asy}

这也未尝不可, 可是再要求多画几个,大家也就会觉得烦了. 编程语言都提供一种
叫 |for| 循环的语句去干这个事情.

\begin{center}\includegraphics[scale=0.6]{For-Circle.pdf}\end{center}%
\lstinputlisting{For-Circle.asy}

我们解释一下 |for| 括号里面三个语句的意思.
\begin{itemize}
\item 第一个语句 |int i=1;| 是对变量 |i| 赋予初始值
  |1|;
\item 第二个语句 |i<4;| 是判断 |i| 是否小于 |4|,
  如果是, 就执行 |draw(circle(O,i));|
\item 第三个语句  |++i| 把 |i| 增加 |1|.
\end{itemize}

按照这个规律,  与 |i=1| 对应的 |draw(circle(O,1))| 是最先执行的. 然后
|i++| 使得 |i| 从 |1| 增加到 |2|, 仍然满足 |i<4| 这个的条件, 因此, 接
下去可以执行 |i=2| 对应的 |draw(circle(O,2))|. 做完以后把 |i++| 又使得
|i| 从 |2| 增加到 |3|, |i=3| 对应的 |draw(circle(O,3))| 被执行. 最后,
变量 |i| 增加到 |4|. 由于此时 |i| 已经增加到了 |4|, 不再满足 |i<4|
的条件, 因此|for| 就此停止工作. 

我们看到, 现在也是恰好画了半径分别为 |i=1|, |i=2|,|i=3| 的三个同心圆,
是不是很神奇!  

下面再列举一些简单的例子.
\begin{center}\includegraphics[scale=0.6]{For-Dots.pdf}\end{center}%
\lstinputlisting{For-Dots.asy}

\begin{center}\includegraphics[scale=0.6]{For-Ellipses.pdf}\end{center}%
\lstinputlisting{For-Ellipses.asy}

\begin{center}\includegraphics[scale=0.6]{For-Grid.pdf}\end{center}%
\lstinputlisting{For-Grid.asy}

下面的例子稍微复杂一些, 即先在一个 |picture pic;| 里面画好一个基本的图
形, 然后通过平移达到铺砌平面.
\begin{center}\includegraphics[scale=0.8]{For-Square.pdf}\end{center}%
\lstinputlisting{For-Square.asy}

由于循环的应用大部分是与数组结合起来的, 因此我们后面还有讨论一下数组以
及它的应用, 到时候我们有更为精彩的例子可以介绍.

\section{与向量 pair  有关的一些函数}
我们先归纳一下与向量 pair 这种数据类型有关的一些知识.

\begin{typelist}
\item[int] 整数类型; 如果没有给定初始式, 默认值为 |0|. 整数允许的最小值
  为 |intMin|, 最大值为 |intMax|. 我们可以用 
  \begin{lstlisting}
    write(intMin);
    write(intMax);
  \end{lstlisting}
  看看这两个数.

\item[real] 实数; 它将设为计算机结构的本地浮点类型的最大精度. 实数的隐式
  初始式为 |0.0|. 实数具有精度 |realEpsilon|, 有效数字为 |realDigits|. 最小的
  正实数为 |realMin|, 而最大的正实数为 |realMax|. 

\item[pair] 向量, 也看成是复数, 实数构成的有序对 |(x, y)|. 复数 |z| 的实部和虚部可读为
  |z.x| 和 |z.y|. 我们称 |x| 和 |y| 为复数数据元素的虚拟成员; 然而, 它们不能
  直接修改. 复数的隐式初始式为 |(0.0,0.0)|. 

  \begin{funclist}
  \item |pair conj(pair z)| \go
    返回 |z| 的复共轭. 

  \item |real length(pair z)| \go
    返回向量 |z| 的长度, 即复数的模. 
  \item |real abs(pair z)|\go
    与 |length(pair)| 功能一样.

  \item |real angle(pair z)| \go
    返回 |z| 的幅角, 单位为弧度, 在区间 $[-\uppi, \uppi]$ 内取值.

  \item |real degrees(pair z, bool warn=true)| \go
    返回 |z| 的幅角, 单位为度, 在区间 $[0,360)$ 内, 当 |warn| 为 |false| 且
    |z.x=z.y=0| 时返回 |0|（而不是产生错误）. 这个 |warn=flase| 可以在与
    极坐标互相转换时避开 |(0,0)| 这个奇点. 
    
  \item |pair unit(pair z)| \go
    返回与复数 |z| 同方向的单位向量.

  \item |pair expi(real angle)| \go
    返回以弧度角 |angle| 为方向的单位向量, 这里用 |expi| 这个符号是源于
    $e^{i\theta}$.

  \item |pair dir(real degrees)| \go
    返回以角度 |degrees| 为方向的单位向量,
    
  \item |real xpart(pair z)| \go
    返回 |z.x|.

  \item |real ypart(pair z)| \go
    返回 |z.y|.
  
  \item |real dot(pair z, pair w)| \go
    返回点积 (内积) |z.x*w.x+z.y*w.y|

  \item |pair minbound(pair z, pair w)| \go
    返回 |(min(z.x,w.x),min(z.y,w.y))|.

  \item |pair maxbound(pair z, pair w)| \go
    返回 |(max(z.x,w.x),max(z.y,w.y))|. 
  \end{funclist}
  
\end{typelist}

\section{Bezier 曲线的原理及与 path 有关函数}
Asymptote 画曲线与通常的其他软件不一样, 并非采用折线逼近来生成曲线的
办法, 而是采用一种称为 Bezier 曲线办法. 我们在此花一些篇幅来介绍这个概
念. 因为一旦我们理解 Asymptote 这种生成曲线或曲面的方法, 将会有助于我
们理解 Asymptote 的与路径 |path| 相关的一些命令, 做到心中有数, 也有助
于灵活地解决问题. 

我们前面已经懂得如何画直线段, 如何生成曲线呢? 1959 年, 法国人 Paul de
Casteljau(与此独立地, 1962 年的 Bezier) 发现了现在称为 Bezier 曲线的生
成光滑曲线的办法. 我们在此阐述一下其中巧妙的想法.

\begin{center}\includegraphics{Bezier-Principle-1.pdf}\end{center}%
\lstinputlisting{Bezier-Principle-1.asy}

给出 $Z_{0}$ 和 $Z_{1}$ 两个点, 我们只能得到连接它们的直线段, 此时如果
给出一个时刻 |t|, 那么我们可以通过这个时刻访问到这条线段上以 $t$
为比例的点, 即 $(1-t)Z_{0}+t Z_{1}$. de Casteljau 天才的想法是添加一个额
外的点 $C$, 并且把它称为控制点. 然后我们顺次连接 $Z_{0}$, $C$, $Z_{1}$, 只
能得到一段折线, 下面我们按照一个比例 $t$ (我们也称为时刻 $t$), 比如
$t=\frac{1}{3}$, 然后在 $Z_{0}$ 到 $C$ 的 $\frac{1}{3}$ 处取一个点
$A$, 同样, 在 $C$ 到 $Z_{1}$ 的 $\frac{1}{3}$ 处取另外一个点 $B$, 连接 $A$
与 $B$, 然后在 $A$ 到 $B$ 的 $\frac{1}{3}$ 处再取点 $Z$, 那么就称 $Z$
为对应于这个时刻 $\frac{1}{3}$ 一个点. 我们可以想象, 当那些时刻遍历
$0$ 到 $1$ 的所有的时刻, 就得到一条轨迹, 通过简单的代数运算, 我们可以
依次得到
\begin{gather}
  A=(1-t)Z_{0}+tC \label{one}\\
  B=(1-t)C+tZ_{1}\label{two}\\
  Z=(1-t)A+tB\label{three}
\end{gather}
把 \eqref{one} 和 \eqref{two} 代入 \eqref{three}, 我们可以得到 $Z$ 与
$t$ 的关系.
\begin{displaymath}
  Z(t)=(1-t)^{2}Z_{0}+2t(1-t)C+t^{2}Z_{1}
\end{displaymath}
这是一条过 $Z_{0}$ 和 $Z_{1}$ 的二次参数曲线. 
这种 BeZier 曲线有许多良好的性质, 比如我们可以不用真正的遍历 $0$ 到
$1$ 之间的所有时刻, 只需按照计算机通常的迭代办法, 分别就刚才的
$Z_{0}$, $A$, $Z$ 与 $Z$, $B$, $Z_{1}$ 重复刚才的做法(那个比例 $\frac{1}{3}$
固定), 又可以得到其他两个该曲线上的点, 这样做足够多却是有限多次, 就能
生成一条肉眼看起来是连续的曲线. 

我们上面得到的是 $2$ 次的参数曲线, 如果采用两个控制点, 那么我们就能得
到 $3$ 次的 Bezier 曲线, 其中的原理是类似的,  请观察图.
\begin{displaymath}
  (1-t)^{3}z_{0}+3t(1-t)^{2}c_{0}+3t^{2}(1-t)c_{1}+t^{3}z_{1}
\end{displaymath}
Asymptote 里面就是采用这种 $3$ 次曲线. 我们可以把这种生成曲线的方式推
广到曲面.而且这种\emph{逐点}的方式非常有利用我们以后产生光滑渐
变的染色效果(请参见后面 3D 曲面的颜色渐变效果部分)

\begin{center}\includegraphics[scale=1.2]{Bezier-Principle-2.pdf}\end{center}%
\lstinputlisting{Bezier-Principle-2.asy}

下面我们介绍一下与路径 |path| 有关的一些函数.

\begin{funclist} |pair point(path p,real t)| \go
我们在前面已经介绍了 Bezier 曲线的生成原理, 从中我们可以知道, 对于一条
这种两个控制点的 3 次 Bezier 曲线, 随便给出一个时刻 |t|, 我们是可以很
简单的得出时刻 |t| 对应的点.
\end{funclist}

\section{数组}
我们经常要表示一列对象 $A_{0}$, $A_{1}$, $A_{2}$, $\cdots$, 它们具有相同
的类型.

\end{document}






